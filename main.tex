\documentclass[14pt]{extarticle}


\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{color}
\usepackage{listings}
\usepackage{indentfirst} % Красная строка
\usepackage{setspace}
\usepackage[default]{cantarell}
\usepackage{enumitem}

\setstretch{1.5}

\lstset{
  basicstyle=\linespread{.94}\ttfamily,
  columns=fixed,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\renewcommand{\lstlistingname}{Листинг}
\renewcommand{\lstlistlistingname}{Список \lstlistingname ов}

\def\code#1{\texttt{#1}}

\title{Исследование деталей реализации отладчика GHCi}
\author{Денис Мирзоев}

\date{Май 2018}

\begin{document}

\maketitle 
\newpage

\tableofcontents
\newpage

\section{Введение}

Отладка -- это процесс устранения ошибок в программе. Для его упрощения
разработчки используют специальные прогрммы-отладчики. Они обладают общирным
набором средств контроля за выполнением программы. 

Хотя все отладчики различаются с точки зрения функциональности, можно выявить
общие принципы работы, присущие большинству из них. К примеру, часто бывает
удобно остановить работу программы в месте предполагаемой ошибки и посмотреть
значения доступных в этот момент переменных. Кроме того, отладчики позволяют
выполнять программу ``шаг за шагом``, то есть выполнять каждый раз лишь одну
строку программы. Это помогает после остановки проследить изменение значений
переменных и саму последовательность выполнения инструкций.

В данной работе мы исследуем детали реализации отладчика языка Haskell,
встроенного в интерпретатор GHCi. Особый интерес заключается в том, что
Haskell является языком программирования с ленивой стратегией вычисления. Это
означает, что порядок вычисления не задан явно.

Чтобы показать, в чём заключается это разительное отличие рассмотрим два
простых примера.

\begin{lstlisting}[language=c, caption=Делим два числа на Си, label={lst:divFooBarC}]
int divFooBar(void) {
    int foo, bar;
    foo = ...;
    bar = ...;
    return foo / bar;
}
\end{lstlisting}

В листинге \ref{lst:divFooBarC} приведён пример на языке Си. Последовательнось
выполнения \code{divFooBar} будет такой и только такой: сначала вычислится
значение \code{foo}, потом вычислится \code{bar}, потом вычислится результат.

\begin{lstlisting}[caption=Делим два числа на Haskell, label={lst:divFooBarHaskell}]
divFooBar =
    let foo = ...
        bar = ...
    in foo `div` bar
\end{lstlisting}

Код в листинге \ref{lst:divFooBarHaskell} делает то же самое. Разница
заключается в ленивости. Значения в Haskell не вычисляются сразу. Вычисление
выражения начинается только в тот момент, когда понадобится его результат. В
связи с этим становится трудно сказать в каком порядке будет выполняться
программа. \code{foo} и \code{bar} могут быть вычислены в любом порядке.

По этой причине GHCi имеет сложное устройство и не похож на отладчики
традиционных языков программирования.

\section{GHCi}

GHCi -- это интерпретатор Haskell кода. Он является частью GHC, компилятора
языка Haskell. GHCi позволяет вычислять значения и интерпритировать код. Кроме
того, в его состав входит отладчик.

\section{Компиляция}

GHC поддерживает несколько режимов компиляции:

\begin{itemize}
\item Си
\item машиннный код
\item LLVM 
\item GHCi
\end{itemize}

\begin{lstlisting}[float, floatplacement=H, label={lst:compilation},
caption=Схема процесса компиляции]
           +-------------+
           | source code |
           +-------------+
                 | (1)
                 v
              +-----+
              | AST |
              +-----+
                 | (2)
                 v
             +------+
             | Core |----------------+
             +------+                | (5)
                 | (3)               |
                 v                   |
            +----------+             |
       +----| STG, C-- |--+          |
       |    +----------+  | (4)      |
       v         |        v          |
  +---------+    |      +---+        |
  | LLVM IR |    |      | C |        |
  +---------+    |      +---+        |
       |         v        |          v
       |   +-----------+  |    +----------+
       +-->| Assembly  |<-+    | Bytecode |
           +-----------+       +----------+
\end{lstlisting}

В листинге \ref{lst:compilation} приведена схема процесса компиляции.
Рассмотрим её более подробно. В прямоугольниках обозначена форма представления
программы на текущем этапе.

\begin{enumerate}[label={(\arabic*)}]

\item Лексический и синтаксический анализ исходного кода,
результатом которого является абстрактное синтаксическое дерево(AST). 

\item Абстрактное синтаксическое дерево транслируется во внутреннее представление
именуемое Core.

\item Сначала Core переводится в более низкоуровневое представление именуемое STG, далее
в C-{}-.

\item Кодогенерация. C-- транслируется в ещё одно промежуточное представление,
которое зависит от кодогенератора. Это может быть C, промежуточный код LLVM или
ассемблер. В конечном итоге все представления транслируются в ассемблер или в
машинный код в зависимости от опций компиляции.

\item Генерация байткода. Этот способ компиляции используется интерпретатором.
В отличие от компилятора интерпретатору нужно получить не машинный код, а байткод.

\end{enumerate}

\section{Среда времени выполнения}

fdsaf


\section{Пример работы с отладчиком GHCi}

\subsection{Точки останова}

Рассмотрим простую программу, осуществляющую сортировку списка целых чисел
алгоритмом бытрой сортировки.

\begin{lstlisting}[caption=main.hs]
qsort [] = []
qsort (a:as) = qsort left ++ [a] ++ qsort right
 where 
  left  = filter (<=a) as
  right = filter (a<) as

main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
\end{lstlisting}

Сначала загрузим её в интерпретатор.

\begin{lstlisting}
$ ghci main.hs
GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling Main             ( main.hs, interpreted )
Ok, modules loaded: Main.
*Main>
\end{lstlisting}

Теперь можно установить точку останова. Давайте сделаем это на второй части
определения \code{qsort}.

\begin{lstlisting}
*Main> :break 2
Breakpoint 0 activated at main.hs:2:16-47
*Main>
\end{lstlisting}

Команда \code{:break 2} устанавливает точку останова на строке 2 последнего
загруженного модуля. В нашем случае это \code{main.hs}. Она выбирает самое
левое полное подвыражение на этой строке(\code{qsort left ++ [a] ++ qsort
right}).

Теперь можно запустить программу.

\begin{lstlisting}
*Main> :main
Stopped in Main.qsort, main.hs:2:16-47
_result :: [Integer] = _
a :: Integer = 8
left :: [Integer] = _
right :: [Integer] = _
[main.hs:2:16-47] *Main> 
\end{lstlisting}

Выполнение приостановлено на точке останова. Подсказка ввода изменилась,
демонстрируя, что мы остановились и где мы остановились:
\code{main.hs:2:16-47}. Помимо этого выводится список доступных переменных.
Для отображения значения переменной есть команда \code{:print}.

\begin{lstlisting}
[main.hs:2:16-47] *Main> :print left
left = (_t1::[Integer])
\end{lstlisting}

Заметим, что \code{left} не был вычислен, поэтому в его отображении отсутствуют
подробности. Можно потребовать его вычисления. Для этого существует команда
\code{:force}.

\begin{lstlisting}
[main.hs:2:16-47] *Main> :force left
left = [4,0,3,1]
\end{lstlisting}

\subsection{Доступные команды}

\begin{itemize}
\item \code{:break} устанавливает точку останова;
\item \code{:force} и \code{:print} показывают значение выражения. Разница между ними в
том, что \code{:force} принудительно вычисляет его значение, а \code{:print} нет.
\item \code{:history} последние выполненные шаги вычисления;
\item \code{:forward} и \code{:backward} перемещаются по истории вперед и назад
соответственно;
\item \code{:trace} включает историю вычислений;
\item \code{:step} производит один шаг вычисления;
\item \code{:continue} продолжает выполнение вычисления после остановки.
\end{itemize}

\section{Заключение}

\end{document}
