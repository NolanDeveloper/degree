\documentclass[14pt]{extarticle}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{color}
\usepackage{listings}
\usepackage{indentfirst} % Красная строка
\usepackage{setspace}
\usepackage[default]{cantarell}
\usepackage{enumitem}

\setstretch{1.5}

\lstset{
  basicstyle=\linespread{.94}\ttfamily,
  columns=fixed,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  numbers=left,
  belowskip=1ex,
  abovecaptionskip=0em,
  belowcaptionskip=1ex,
  aboveskip=1em,
}

\renewcommand{\lstlistingname}{Листинг}
\renewcommand{\lstlistlistingname}{Список \lstlistingname ов}

\def\code#1{\texttt{#1}}

\title{Исследование деталей реализации отладчика GHCi}
\author{Денис Мирзоев}

\date{Май 2018}

\begin{document}

\maketitle 
\newpage

\tableofcontents
\newpage

\section{Введение}

Отладка -- это процесс устранения ошибок в программе. Для его упрощения
разработчки используют специальные прогрммы-отладчики. Они обладают общирным
набором средств контроля за выполнением программы. 

Хотя все отладчики различаются с точки зрения функциональности, можно выявить
общие принципы работы, присущие большинству из них. К примеру, часто бывает
удобно остановить работу программы в месте предполагаемой ошибки и посмотреть
значения доступных в этот момент переменных. Кроме того, отладчики позволяют
выполнять программу ``шаг за шагом``, то есть выполнять каждый раз лишь одну
строку программы. Это помогает после остановки проследить изменение значений
переменных и саму последовательность выполнения инструкций.

В данной работе мы исследуем детали реализации отладчика языка Haskell,
встроенного в интерпретатор GHCi. Особый интерес заключается в том, что
Haskell является языком программирования с ленивой стратегией вычисления. Это
означает, что порядок вычисления не задан явно.

Чтобы показать, в чём заключается это разительное отличие рассмотрим два
простых примера.

\begin{lstlisting}[language=c, caption=Делим два числа на Си, label={lst:divFooBarC}]
int divFooBar(void) {
    int foo, bar;
    foo = ...;
    bar = ...;
    return foo / bar;
}
\end{lstlisting}

В листинге \ref{lst:divFooBarC} приведён пример на языке Си. Последовательнось
выполнения \code{divFooBar} будет такой и только такой: сначала вычислится
значение \code{foo}, потом вычислится \code{bar}, потом вычислится результат.

\begin{lstlisting}[caption=Делим два числа на Haskell, label={lst:divFooBarHaskell}]
divFooBar =
    let foo = ...
        bar = ...
    in foo `div` bar
\end{lstlisting}

Код в листинге \ref{lst:divFooBarHaskell} делает то же самое. Разница
заключается в ленивости. Значения в Haskell не вычисляются сразу. Вычисление
выражения начинается только в тот момент, когда понадобится его результат. В
связи с этим становится трудно сказать в каком порядке будет выполняться
программа. \code{foo} и \code{bar} могут быть вычислены в любом порядке.

По этой причине GHCi имеет сложное устройство и не похож на отладчики
традиционных языков программирования.

\section{GHCi}

GHCi -- это интерпретатор Haskell кода. Он является частью GHC, компилятора
языка Haskell. GHCi позволяет вычислять значения и интерпритировать код. Кроме
того, в его состав входит отладчик.

\subsection{Доступные команды}

\begin{itemize}
\item \code{:break} устанавливает точку останова;
\item \code{:force} и \code{:print} показывают значение выражения. Разница между ними в
том, что \code{:force} принудительно вычисляет его значение, а \code{:print} нет.
\item \code{:history} последние выполненные шаги вычисления;
\item \code{:forward} и \code{:backward} перемещаются по истории вперед и назад
соответственно;
\item \code{:trace} включает историю вычислений;
\item \code{:step} производит один шаг вычисления;
\item \code{:continue} продолжает выполнение вычисления после остановки.
\end{itemize}

\subsection{Пример работы с отладчиком GHCi}

Рассмотрим простую программу, осуществляющую сортировку списка целых чисел
алгоритмом бытрой сортировки.

\begin{lstlisting}[caption=main.hs]
qsort [] = []
qsort (a:as) = qsort left ++ [a] ++ qsort right
 where 
  left  = filter (<=a) as
  right = filter (a<) as

main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
\end{lstlisting}

Сначала загрузим её в интерпретатор.

\begin{lstlisting}
$ ghci main.hs
Ok, modules loaded: Main.
*Main>
\end{lstlisting}

Теперь можно добавить точку останова. Давайте сделаем это на второй части
определения \code{qsort}.

\begin{lstlisting}
*Main> :break 2
Breakpoint 0 activated at main.hs:2:16-47
\end{lstlisting}

Команда \code{:break 2} устанавливает точку останова на строке 2 последнего
загруженного модуля. В нашем случае это \code{main.hs}. Она выбирает самое
левое полное подвыражение на этой строке(\code{qsort left ++ [a] ++ qsort
right}).

Теперь можно запустить программу.

\begin{lstlisting}
*Main> :main
Stopped in Main.qsort, main.hs:2:16-47
_result :: [Integer] = _
a :: Integer = 8
left :: [Integer] = _
right :: [Integer] = _
[main.hs:2:16-47] *Main> 
\end{lstlisting}

Выполнение приостановлено на точке останова. Подсказка ввода изменилась,
демонстрируя, что мы остановились и где мы остановились:
\code{main.hs:2:16-47}. Помимо этого выводится список доступных переменных.
Для отображения значения переменной есть команда \code{:print}.

\begin{lstlisting}
[main.hs:2:16-47] *Main> :print left
left = (_t1::[Integer])
\end{lstlisting}

Заметим, что \code{left} не был вычислен, поэтому в его отображении отсутствует
полный список значений. Можно потребовать его вычисления. Для этого существует
команда \code{:force}. 

\begin{lstlisting}
[main.hs:2:16-47] *Main> :force left
left = [4,0,3,1]
\end{lstlisting}

Стоит отметить, что вычисление подвыражения может не завершаться или
завершаться с ошибкой даже в том случае, когда выражение целиком всегда
завершается успешно. Рассмотрим пример.

\begin{lstlisting}[caption=main.hs]
a = 0
b = 1 `div` a
foo = if a == 0 then 0 else b
\end{lstlisting}

Результатом вычисления foo будет ноль, а вовсе не ошибка как можно подумать,
заметив деление на ноль в строке 2. Это происходит благодаря ленивой стратегии
вычисления. Значение \code{b} не вычисляется, потому что его результат
никогда не требуется. Теперь давайте попробуем 

\begin{lstlisting}
$ ghci main.hs
*Main> :force b
*** Exception: divide by zero
\end{lstlisting}

\subsection{История вычислений}

В традиционных отладчиках существует понятие стека вызова функций. После
остановки в некотором месте программы он помогает понять, откуда мы туда
пришли. 

Стек состоит из адресов возврата функций, которые вычисляются в данный момент,
в порядке обратном порядку их вызова. По нему можно перемещаться, выясняя
значения локальных переменных в этих функциях.

Похожий доступ к стеку можно получить и в Haskell, но это требует компиляции с
опцией \code{-prof}, которая включает оснащение кода системой профилирования.
Такой режим компиляции несовместим с отладчиком. 

Существует альтернатива - история вычислений. Выражения в Haskell вычисляются
по мере необходимости, поэтому важнее стека вызовов может оказаться именно
последовательность предпринятых шагов вычисления. Историю таких шагов можно
получить с помощью команд \code{:trace} и \code{:hist}. Рассмотрим пример.

\begin{lstlisting}
*Main> :list qsort
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
*Main> :b 1
Breakpoint 0 activated at main.hs:1:12-13
\end{lstlisting}

Запустим сортировку небольшого списка с трассировкой с помощью команды \code{:trace}.

\begin{lstlisting}
*Main> :trace qsort [3, 2, 1]
Stopped in Main.qsort, main.hs:1:12-13
_result :: [a] = _
\end{lstlisting}

Теперь мы можем историю шагов вычисления. Сделать это можно командой \code{:hist}.

\begin{lstlisting}
[main.hs:1:12-13] *Main> :hist
-1  : qsort:left (main.hs:4:12-26)
-2  : qsort (main.hs:2:16-25)
-3  : qsort (main.hs:2:16-47)
-4  : qsort:left (main.hs:4:12-26)
-5  : qsort (main.hs:2:16-25)
-6  : qsort (main.hs:2:16-47)
-7  : qsort:left (main.hs:4:12-26)
-8  : qsort (main.hs:2:16-25)
-9  : qsort (main.hs:2:16-47)
<end of history> 
\end{lstlisting}

\section{Компиляция}

GHC поддерживает несколько режимов компиляции:

\begin{itemize}
\item Си
\item машиннный код
\item LLVM 
\item GHCi
\end{itemize}

\begin{lstlisting}[float, floatplacement=H, label={lst:compilation},
caption=Схема процесса компиляции]
           +-------------+
           | source code |
           +-------------+
                 | (1)
                 v
              +-----+
              | AST |
              +-----+
                 | (2)
                 v
             +------+
             | Core |----------------+
             +------+                | (5)
                 | (3)               |
                 v                   |
            +----------+             |
       +----| STG, C-- |--+          |
       |    +----------+  | (4)      |
       v         |        v          |
  +---------+    |      +---+        |
  | LLVM IR |    |      | C |        |
  +---------+    |      +---+        |
       |         v        |          v
       |   +-----------+  |    +----------+
       +-->| Assembly  |<-+    | Bytecode |
           +-----------+       +----------+
\end{lstlisting}

В листинге \ref{lst:compilation} приведена схема процесса компиляции.
Рассмотрим её более подробно. В прямоугольниках обозначена форма представления
программы на текущем этапе.

\begin{enumerate}[label={(\arabic*)}]

\item Лексический и синтаксический анализ исходного кода,
результатом которого является абстрактное синтаксическое дерево(AST). 

\item Абстрактное синтаксическое дерево транслируется во внутреннее представление
именуемое Core.

\item Сначала Core переводится в более низкоуровневое представление именуемое STG, далее
в C-{}-.

\item Кодогенерация. C-{}- транслируется в ещё одно промежуточное представление,
которое зависит от кодогенератора. Это может быть C, промежуточный код LLVM или
ассемблер. В конечном итоге все представления транслируются в ассемблер или в
машинный код в зависимости от опций компиляции.

\item Генерация байткода. Этот способ компиляции используется интерпретатором.
В отличие от компилятора интерпретатору нужно получить не машинный код, а байткод.

\end{enumerate}

\section{Среда времени выполнения}

Интерпретацией байткода занимается среда времени выполнения. Такое
архитектурное решение позволило реализовать взаимодействие байткода и машинного
кода.

\section{Заключение}

\end{document}
